#Toteutus

###Rakenne

Tekoälyni logiikka koostuu kahdesta osasta: evaluaatiofunktiosta ja ailogic-luokasta. Evaluaatiofunktion vastuulla on pelitilanteiden arvostelu huomioiden molempien pelaajien nappuloiden materiaaliarvot, sijaintikohtaiset arvot ja liikkuvuus. Ailogic-luokka on vastuussa seuraavan siirron laskemisesta hyödyntäen tehostettua negamax-algoritmia. Negamax-algoritmissä kukin pelaaja pyrkii vuorollaan maksimoimaan huonoimman mahdollisen arvon, jonka vastustaja voi pakottaa pelaajan saamaan siirtojen seurauksena. 

Käytän negamaxin tehostamiseen useita eri keinoja, joten tässä niistä lyhyt esittely. Aloitetaanpa alfa-beeta karsinnalla, joka on kaikkien nopeutusten takana. Alfa-beeta karsinnan ideana on karsia varmasti parasta tähän astista siirtoketjua huonommat pois karsien parhaimmassa tapauksessa jopa 97% tapauksista syvyydellä 3 (ensimmäinen kokeiltu siirtoketju oli paras) ja huonoimmassa karsien 0 tapausta (siirtoketjut järjestyksessä huonoimmasta parhaimpaan). Näin alfa-beeta karsinta ei valitettavasti pienennä ohjelman O-notaatio aikavaativuutta, vaikka keskimääräinen aikavaativuus tippuukin todella paljon. Tämän vuoksi suurin osa muista nopeutuksista perustuukin siirtojen käsittelyyn paremmassa järjestyksessä. 

Alfa-beeta karsinnan lähtökohdat seuraavassa lyhyesti esimerkin avulla. Oletetaan, että meillä on pelipuussa solmu syvyydellä 1, josta paras löydetty siirtoketju johtaa paluu arvoon 5. Nyt tutkimme kyseisen solmun toista lasta c syvyydellä 2 ja huomaamme yhden lapsista olevan arvoltaan 4. Tästä seuraa, että syvyydellä 2 pelaavan pelaajan näkökulmasta lapsi on arvoltaan -4 ja koska tämä pelaaja maksimoi tilanteen arvon omasta näkökulmastaan, täytyy c:n olla arvoltaan vähintään -4. Näin syvyydellä 1 siirtonsa pelaavan pelaajan näkökulmasta c:n arvo voi olla enintään -(-4)=4<5 ja näin tiedämme, ettei muita c:n lapsia tarvitse tutkia, sillä ne eivät voi johtaa parannukseen. Näin alfa-beeta karsinta onkin sitä tehokkaampi, mitä nopeammin paras tähän astinen arvomme (kutsutaan alfa-arvoksi) lähestyy koko tutkinnan parasta arvoa.

Iteratiivisen syvennyksen ideana on, että halutessamme parhaan siirron rekursiosyvyydelle n asti yltävällä iteraatiolla, emme suoraan iteroi syvyydelle n. Sen sijaan iteroimme aluksi syvyydelle yksi kirjaten muistiin paras yksittäinen siirto, sitten iteroimme syvyydelle kaksi kokeillen ensin aloittaa parhaalla yksittäisellä siirrolla ja kirjaamme jälleen ylös paras kahden siirron ketju. Jatkaessamme tätä eteenpäin teemme pahimmassa tapauksessa paljon turhaa työtä (tutkimme 100/haarautuvuus prosenttia turhia solmuja), mutta shakissa tämä vastaa alle 2% turhaa työtä, kun taas säästämme alfa-beeta karsinnassa paljon enemmän. Ja mikä parasta, ylimääräinen työ on sitä pienempi, mitä enemmän mahdollisia siirtoja, eli mitä raskaampi operaatio olisi muulloin.

Viimeinen käyttämäni heuristiikka on 'tappajasiirrot'. Tappajasiirrot ovat siirtoja, jotka johtivat aiemmin samalla syvyydellä alfa-beta karsinnassa solmujen katkaisuun karsien osan pelipuusta pois. Säilytän näitä maksimissaan kolme jokaisella syvyydellä pelipuussa ja korvaan vanhimman aina uudella, jos uusi siirto löytyy. Näiden siirtojen tehostavan vaikutuksen takana on ns. 'killer-heuristic', jonka mukaan samalla rekursiosyvyydellä on luultavasti melko samanlainen tilanne, jolloin sama siirto on paras tai ainakin yksi parhaista kyseisessäkin tilanteessa.

Transpositiotaulun ideana on tallentaa dynaamiseen muistiin kyseisen pelitilanteen arvo molempien pelaajien näkökulmista, kun on kyseisen pelaajan vuoro ja iteraatio jatkuu vielä n siirtoa. Näin samassa tilanteessa ei arvoa tarvitse enää laskea uudelleen myöhemmin pelin aikana. Iteraation jatkuessa 0 askelta tulee siis kirjattua ylös kyseisen pelitilanteen saama arvo evaluaatiofunktiosta.

Toinen käyttämäni dynaamisen muistin sovellus on vanhojen iteraatioiden hyödyntäminen aloitettaessa seuraavan siirron etsiminen. Ennen iteraation aloitusta otan aiemman iteraation parhaasta siirtoketjusta p-t viimeistä siirtoa, missä p on plies eri maksimi rekursiosyvyys, jonon rekursiossa ollaan menossa, ja t on turns eli vuoroja viime iteraation suorituksesta. Nämä siirrot siirretään nyt järjestys ylläpitäen uuden parhaansirrtoketjun principalMoves kärkeen todennäköisinä vaihtoehtoina parhaan uuden ketjun aluksi. Saman lainen operaatio tehdään myös tappajasiirroille, jolloin meillä on heti alusta lähtien käytössä oletettavasti hyviä siirto vaihtoehtoja. Loput tappajasiirrot ja parhaan siirtoketjun osat alustetaan nulleiksi, jottei väärää tietoa käytettäisi.

Tekoälyn hyödyntämät tietorakenteet on koottu kansioon datastructures. Rakenteet vastaavat aika- ja tilavaativuuksiltaan Javan valmiita rakenteita ja olen toteuttanut vain työssäni tarvittavat metodit.
